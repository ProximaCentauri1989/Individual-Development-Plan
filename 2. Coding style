1. Найдите ошибки в приведенном коде:

// Library1.h

#define BOOL int
#define FALSE 0
#define TRUE 1

BOOL CheckFile(char* name);

// Library2.h

#define ERR_NODATA 42

// Client.cpp

int result = ParseFile(CheckFile);
if (result = ERR_NODATA) {
    // ...
}

========================================================1. ОТВЕТ======================================================================
Вместо макросов лучше использовать модификатор const. Хоть в данном случае макросы и просты, все же макросы советуется использовать 
только в тех случаях когда нет другого выхода. Любой макрос свидетельствует о несовершенстве ЯП, программы или программиста. 
Макросы это просто средство подстановки текста и они почти никогда не являются необходимыми в С++. В перспективе пропроцессор могут вовсе 
убрать. Поэтому для определения констант лучше использовать const. Первый #define можно убрать вообще, и если реально нужен псевдоним 
типа лучше использовать using (хотя он скорее используется в случае создания псевдонимов для "длинных" не POD-типов чем для 
таких как int):

using BOOL = int

Остальные #define-ы заменить на const:

const int FALSE = 0
const int TRUE = 1
const int ERR_NODATA = 42

В операторе if допущена ошибка, и вместо сравнения значения result c константой ERR_NODATA выполняется присваивание. Таким образом,
данное условие всегда будет истинно:

if (result = ERR_NODATA) {
    // ...
}
===================================================================================================================================


2. Снова рассмотрим функцию из задачи к главе 1:
int PasswordCount(int a, int n, int m, std::vector<int>& result)
{
    int sum;
    for (int i = n; i <= m; i++)
    {
        sum = 0;
        for (int j = n; j < i; j++)
        {
            sum += static_cast<int>(std::pow(a, j));
        }
        result.push_back(sum);
    }
    return sum;
}
Какая ошибка имеется в данной функции в связи с несоблюдением правил кодирования 18-19?


========================================================2. ОТВЕТ======================================================================
Переменная sum не инициализирована до входа в цикл. При условии если n > m sum никогда не получит значение и будет осущестувлен возврат
неинициализированной переменной (runtime error).
===================================================================================================================================

3. Снова рассмотрим пример с регистрацией обработчиков из главы 1:
// IHandler.h

class IHandler
{
public:
    virtual ~IHandler() = default;
};

// HandlerRegistry.h
extern std::map<std::string, IHandler*> g_handlerRegistry;

// HandlerRegistry.cpp
#include <map>
#include "IHandler.h"
#include "HandlerRegistry.h"

std::map<std::string, IHandler*> g_handlerRegistry;

// Handler1.cpp
#include <map>
#include "IHandler.h"
#include "HandlerRegistry.h"

class Handler1 : public IHandler
{
};

Handler1 g_handler1;

class Handler1Registrator
{
public:
    Handler1Registrator()
    {
        g_handlerRegistry.emplace("Handler1", &g_handler1);
    }
};

Handler1Registrator g_handler1Registrator;

- Найдите в приведенном примере нарушения правил кодирования 21-23.
- К чему приведет изменение порядка директив #include в .cpp файлах?
- Какая ошибка может возникать во время исполнения приведенного кода?
- Сколько файлов нужно будет изменить если разработчик решит заменить std::map на std::unordered_map?

========================================================3. ОТВЕТ======================================================================
Объекты уровня пространства имен в разных единицах компиляции не должны зависеть друг от друга при инициализации, поскольку порядок
инициализации не определен. В // Handler1.cpp при создании объекта g_handler1Registrator идет работу с мапой g_handlerRegistry, которая
находиться в другой единице трансляции HandlerRegistry.cpp. Не определено будет ли вызван конструктор g_handlerRegistry до того как будет
вызван конструктор g_handler1Registrator (будет ли создан реестр до того как мы попытаемся им воспользоваться или нет?). Так же,
присутствует сильное сопряжение (tight coupling) между различными частями программы. Изменение чего-то одного здесь может привести к 
изменению всего. Слабое сопряжение (loose coupling) предполагает  сведение к минимуму числа соединений между разными частями программы.

Изменение порядка директив #include в .cpp файлах приведет к множественным обшикам при компиляции, которые сложны при анализе и устранении.
К примеру, если в Handler1.cpp поменнять порядок с:

#include <map>
#include "IHandler.h"
#include "HandlerRegistry.h"

на:

#include <map>
#include "HandlerRegistry.h"
#include "IHandler.h"

при обьявлении мапы получим ошибку, что IHanler не определен и последующий незадеклалированный идентификатор g_handlerRegistry, 
а так же ряд других связанных с этим ошибок компиляции.

При замене std::map на std::unordered_map придется изменить файлы HandlerRegistry.h, HandlerRegistry.cpp и Handler1.cpp. Данный факт
нарушает принцип расширяемости. Это свойство, позволяющее улучшать систему, не нарушая ее основной структуры. Изменение одного фрагмента
системы не должно влиять на ее другие фрагменты. Внесение наиболее вероятных изменений должно требовать наименьших усилий.
