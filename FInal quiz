1. Что означает совет "один объект - одна задача"?

Это означает, что каждая переменная, функция, пространство имен, модуль, библиотека должны иметь одну зону ответственности
и одно предназначение. Нужно избегать множественной ответственности. Например, предпочтительнее использовать, короткие классы с одним предназначением, которые описывают одну сущность,
маленькие функции, выполняющие реально одну функцию. Обьекты с множественной ответственностью сложны при проектировании и реализации, а так же они имеют большие размеры и сложны в
применении.

2. Зачем использовать идиому RAII? Почему бы не использовать подход new-delete и т.д.

Язык С++ не реализует сборщик мусора, поэтому возможны утечки памяти. если кто-то случайно забудет применить delete к указателю.
RAII реализует идиому "получение ресурса есть инициализация". Для этого, как пример, существуют так называемые смарт-поинтеры, 
которые являются классами, которые инкапсилируют работу с памятью.  Получение ресурса выполняется в конструкторе, а освобождение
ресурса в деструкторе. Таким образом, освобождение ресурсов происходит при выходе за пределы области видимости, в которой создан
RAII-обьект, что сводит к минимуму вероятность возникновения утечек. Классический случай когда это полезно, это когда в функции
возникает исключение и при отматывании стека вызывается деструктор RAII-обьекта, освобождая ресурс либо уменшая счетчик ссылок
на ресурс.  Это позволяет писать безопасный по отношению к исключениям код.

3. Почему следует избегать макросов?

Макросы являются средством замены текста, действующее во время обработки исходного текста препроцессором. Макросы игнорируют 
области видимости, игнорируют прочие возможности и правила языка, и заменяют все символы, которые переопределяют при помощи 
директивы #define, до самого конца файла. При раскрытии макроса проверка компилятором не производится, т.к. его раскрытие, как уже
было сказано ранее, выполняется препроцессором, до того как начнеться проверка семантики и синтаксиса. По этим причинам ошибки 
связанные с макросами трудно-исправимые. Макросы полезны при реализации "стражников включений", когда нужно предотвратить поключение
файла директивой #include или определение через #define, обернув это действие соответствующими директивами. 

4. Как избегать глубокой вложенности функций?

Необходимо разделить функцию на отдельные части, каждая из которых будет соответствовать принципу "одна функция - одна задача", 
т.к. глубонная вложенность как правило нарушает этот принцип, а так же делает функции длинными и сложными при чтении.
При повторении одних и тех же участков кода, стоит выделить их в отдельную функцию. 
Там где напрашивается вложенность if-ов можно попытаться сделать составное условие, то есть обьединить несколько условий оператором &&
Вместо рукописных циклов можно предпочесть STL-алгоритмы когда это возможно.
Вместо использования оператора switch (или череды if-ов) для попыток идентификации полиморфных типов лучше предпочесть динамический 
полиморфизм, то есть вызов виртуальной функции, переопределенной в наследниках.

5.Что такое зависимость инициализаций между единицами компиляций и какие проблемы вызывает?

Когда обьекты, лежащие на уровне пространства имен и они зависят друг от друга при инициализации как раз и устанавливается такая 
зависимость. Один обьект при конструировании может полагаться на то, что сконструирован другой, но при этом абсолютно напрасно, 
если они находяться в разных единицах компиляции, т.к. порядок инициализации таких обьектов не определен, то есть неизвестно 
конструктор какого обьекта будет вызван первым.

6. Почему не следует перегружать операторы &&, ||, ","?

Перегруженные версии &&, ||, "," нарушают привычный порядок работы данных операторов, то есть отличаются от встроенных версий.
Встроенные версии сначала вычисляют левую часть, и, если она (левая часть) false для && или true для || правая часть не вычисляется.
Это позволяет полагаться на вычисление слева от оператора при решении будет ли корректно вычисление справа. Предположим, слева у нас
указатель, а справа его разыменование операцией "->". Тогда имея проверку:

if(ptr && ptr->Func()) 
{
    /*...*/
}

мы не будем разыменовывать указатель ptr справа от &&, если он !ptr.
При перегрузке, образуются побочные эффекты, такие как:
- может вызваться ptr->Func() даже если предварительно установлено, что ptr == nullptr
- порядок вычисления (сначала лево или сначало право) не определен.

То есть, проще говоря, перегруженные версии данных операторов, не гаранитруют ассоциативность "слева-направо" когда она необходима.

7. Почему не следует использовать параметры по умолчанию в виртуальных функциях?

Параметры по умолчанию в виртуальных функциях не следует использовать, т.к. параметры по умолчанию связываются статически, во 
время компиляции. При вызове виртуальной функции без параметра (подразумевая что он будет взят из переопределенной версии) мы 
получаем параметр по умолчанию из версии функции в базовом классе. Казус в том, что при выполнении тела перегруженной версии 
функции мы получаем параметр по умолчанию из класса родителя, и работаем не с тем входным аргументом, который предполагался.

8. В каких случаях могут проявиться неявные преобразования типов?

Могут проявиться когда класс имеет конструктор с одним аргументом (на самом деле могут присутвовать еще и параметры по умолчанию,
но он считается конструктором с одним аргументом когда реально имеется возможность передать только один аргумент).
В таком случае конструктор является одновременно и функцией преобразования из типа аргумента в тип класса. 
Во избежание таких преобразования нужно обьявлять конструктор с ключевым словом explicit.

Так же источником неявных преобразований являются намеренно-определенные в классе операторы преобразования. Их так же можно 
снабжать ключевым словом explicit.

9. Почему стоит предпочитать инициализацию присваиванию в конструкторе?

Когда мы не используем список инициализации членов, а присваивание в теле конструктора это ведет к накладных расходам в виде 
лишних вызовов функций, то есть, до того как вызоветься оператор присваивания, поле класса сконструируется конструктором по умолчанию.
Конструкторы генерируют скрытый код инициализации, поэтому, даже если мы неуказывает явно полей в списке инициализации. 
При этом, порядок инициализации полей соответствует порядку их обьявления.

10. Почему не рекомендуется вызывать виртуальные функции в конструкторе и деструкторе?

В конструкторах и деструкторах вызов виртуальных функций не рассматривается полиморфно, а трактуется как вызов обычной не виртуальной
функции.  Это происходит потому, что члены производного класса, в котором виртуальная функция переопределена, еще не сконструированы 
на момент вызова виртуальной функции в теле конструктора (к слову, в другом С-подобном языке C#, поля конструируются до вызова 
конструктора базового класса, и там вызов полиморфен, но не в С++). Что еще хуже, если виртуальная функция является чистой виртуальной
функцией, то вызов может чаще всего приводит к ошибке компоновки, в виду того, что у функции нет тела (хотя любые книжные источники 
утверждают, что такой вызов это в принципе неопределенное поведение, и ошибка компоновки это меньшее из зол).

11. Почему из деструкторов и функций очистки нельзя выбрасывать исключения?

Перечисленные функции не должны генерировать исключений, так как они являются ключевыми для двух главных операций транзакционного
программирования — отката при возникновении проблем в процессе работы и принятия результата работы, если проблем не возникло.
Если нет способа безопасного возврата в предыдущее состояние при помощи операций, не генерирующих исключения, то невозможно 
реализовать бессбойный откат; отсутствие возможности безопасного сохранения изменения состояния при помощи операции, не генерирующей
исключения, делает невозможной реализацию бессбойного принятия результата работы.

Если деструктор, вызванный в процессе свертки стека, выходит с исключением, вызывается функция terminate, что приведет к завершению
работы всей программы. Поэтому деструкторы должны в общем случае перехватывать исключения и не  позволять им распространиться 
за пределы деструктора.

Поведение класса с деструктором, который позволяет покидать исключению его границы, распространяется на все классы, для которых
он является базовым или у которых имеются члены этого типа. Так же, невозможно будет надежно создавать глобальные обьекты, т.к.
исключения в таких обьектах невозможно перехватить. Так же, невозможно надежно создавать массивы, т.к. при конструировании n-го 
элемента может возникунть исключение, и при дальнейшем вызове деструкторов уже сконструированных обьектов так же могут возникнуть
исключения.

Стандартная библиотека запрещает использование деструкторов, которые могут генерировать исключения, поэтому такие обьекты нельзя
будет использовать в стандартных контейнерах или других частях стандартной библиотеки.

12. Почему нельзя использовать using namespace в хидерах?

Их не стоит использовать в заголовочных файлах, т.к. заголовочные файлы предназначены для включения в неограниченное количество
файлов реализаций cpp, и это может внести конфликты имен в код в этих файлах, т.к. мы импортируем все имена и простанства имен 
в эти файлы. Во всех заголовочных файлах, как и в файлах реализации, до последней директивы #include, всегда необходимо использовать
полностьтю квалифицированные имена. В файлах реализации после всех диреткив #include можно свободно использовать using.

13. Приведите примеры обобщенного кода.

Пример из 7.1. Обобщение для вывода первого элемента контейнера. 

decltype(auto) это фича С++14, позволяет "повторить" возвращаемый тип без срезок.
Таким образом, мы может вернуть первый элемент контейнера, у которого перегружен operator[]().

template<typename T, typename Container> 
decltype(auto) starts_with(Container&& cont)
{
      return std::forward<Container>(cont)[0];
}

Так же, любой STL алгоритм или контейнер являются примером обощенного кода. Контейнеры выполнены
в виде шаблонных класов, и реализуют принцип "код не зависит от типа" (хоть и не в 100% случаев), то есть в них тип - переменная
величина. Алгоритмы же STL, позволяют построить еще более высокую степень обобщенности, реализуя код, охватывающий различные 
контейнеры и принимающий диапазон. Например, можно вызвать алгоритм std::sort для любого контейнера, который обспечивает итератор
произвольного доступа, или алгоритм std::find для контейнера, который обеспечивает однонаправленный итератор.

14. Какие бывают гарантии безопасности исключений и в чём они заключаются?

Существуют:
- базовая гарантия исключений (в случае возникновения исключений не должно быть никаких утечек ресурсов, при возникновении любого исключения в некотором методе, 
                               состояние программы должно оставаться согласованным)
- строгая гарантия исключений (если при выполнении операции возникает исключение, то это не должно оказать какого-либо влияния на состояние приложения. Либо все,
                               либо ничего)
- гарантия отсутствия исключений (ни при каких обстоятельствах функция не будет генерировать исключения)

15. Почему стоит предпочитать операции с диапазонами операциям с отдельными элементами?

Вызов функции с диапазоном проще написать, легче читать и она более эффективна. Функции с диапазонами могут выполнить оптимизацию,
на основе знания о количестве элементов, которые должны быть вставлены. В случае с std::vector, примении функции вставки диапазонами 
приводит к однократному перераспределнию памяти для необходимого количества и дальнейшей вставке. При вставке одного элемента за вызов, таких перераспределений
может быть множество, что ведет к лишним операциям выделения памяти и копирования старых элементов в новый буфер. Кратко говоря, функции с диапазонами
по сравнению с функциями вставки индивидуальных элементов обеспечат меньшую сложность.

16. Что такое "чистая" функция? Почему следует делать предикаты чистыми функциями?

Чистой является функция, результат работы которой зависит только от аргументов, которые передается оператору "круглые скобки" 
operator(), то есть, при передаче одних и тех же агргументов, должен быть всегда один и тот же результат, и этот результат не 
должен зависить ни от каких-либо других факторов. Стандартные алгоритмы не дают гарантии относительно порядка применения 
предикатов к элементам диапазона, поэтому не чистые предикаты (предикаты с состоянием,  результат работы которых зависит не только
от входных аргументов, передающихся в operator(), имеют мало смысла).

17. Почему следует избегать преобразований в стиле С?

Преобразование в стиле С не проверяется компилятором во время компиляции. В С++ преобразование в стиле С срабатывает таким образом,
что в зависимости от кода срабатывает одно из преобразований С++, то есть преобразование типов  в стиле С имеет различную семантику
в зависимости от контекста, спрятанную за единым  синтаксисом. Что конкретно произойдет при таких преобразованиях зависит от таких
мелочей, как, например, какие именно заголовочные файлы включены при помощи директивы #include. Если преобраований не избежать, 
то лучше использовать преобразования в стиле С++, т.к. им присуща четко определенная документированная семантика. К примеру, если
мы попытаемся применить static_cast, указав у него в круглых скобках указатель, который указывает на nullptr, то компилятором
запретит такое преобразование. При преобразования в стиле С (SomeType*)ptr этого не произойдет.

18. Что следует использовать вместо memcpy и memcmp для не-POD типов? Какие проблемы могут возникнуть из-за использование memcpy
и memcmp?

При применение memcpy и memcmp выполняется побитовая копия и побитовое сравнение соответственно. Их примененеи может привести к
неопределенному поведению и утечкам памяти. Для копирования диапазонов объектов лучше использовать стандартный алгоритм std::copy.
При копировании обьекта стоит полагаться на конструктор копирования обьекта и оператор присваивания, использование которых, в отличие
от применения memcpy не нарушает принцип сокрытия информации. memcmp может приводить к некорректным сравнениям, т.к. при применении его
к объектам в сравнении могут участвовать байты данных, которые не являются частью состояния обьекта, что связано с тем, что комиляторы
могут добавлять к обьектам скрытые данные, не являющиеся частью состояния. Применению memcmp лучше  предпочесть перегрузку операторов
сравнения для обьектов.

19. Какие проблемы несет использование троеточий в параметрах функции?

Троеточия нарушают безопасность типов, т.к. их применении компилятор не производит проверку типов.
Сильное связывание и необходимость согласования вызываемого и вызывающего кода вручную. Проверка типов языком оказывается отключена,
так что вызывающий код должен использовать иные способы для сообщения о типах передаваемых аргументов.
Передача чего либо кроме примитивных типов вместо троеточий приводит к неопределенному поведению в С++.
