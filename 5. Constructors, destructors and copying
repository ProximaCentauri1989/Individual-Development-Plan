1. Нарушены следующие правила:
Правило №47. Порядок инициализации полей класса не соответствует порядку их обьявления. В данном конкретном случае, 
ошибок не произойдет, т.к. поля при инициализации не используют друг друга. Порядок инициализации таков:
	1) создать пустую строку m_model;
	2) инициализировать  m_fullNumber(countryCode + number)
	3) инициализировать m_number(number)
	4) инициализировать m_countryCode(countryCode)
	5) присвоить m_model = model;
Если бы, при несоответствии порядка инициализации порядку обьявления, какие-либо поля использовали друг друга, можно было бы получить 
необработанное исключение при попытке использовать переменную, которой еще не существует. Это могло бы пройзоти если бы m_fullNumber 
использовал m_number вместо number, в предположении, что m_number уже существует (поскольку он идет первым в спиcке инициализации).
Правило №48. В конструкторе PhoneInfo поле  m_model получает своё значение путем присваивания в теле конструктора, вместо списка 
инициализации. Получаем один лишний вызов. Сначала конструктор m_model, затем оператор присваивания.
Правило №49. В конструкторе и дестркторе PhoneInfo вызывается виртуальная функция. Виртуальные функции внтури конструкторов и 
деструкторов не рассматриваются как виртуальные.
При этом, функция PhoneInfo - чистая виртуальная функция. Вызов такой функции в конструкторе или деструкторе - неопределенное 
поведение (функция не реализована). Пример того что может произойти: ошибка компоновки (т.к. у функции нету тела).
Правило №50. Класс PhoneInfo используется в качестве базового, но его деструктор не обьявлен как виртуальный. Если попытаться удалить 
производные обьекты имея указатель на PhoneInfo, при отсутствии виртуального деструктора в базовом классе, произойдет утечка памяти
и производная часть обьекта не удалится (только базовая).

Изменения:
Порядок инициализации соответствует порядку обьявления.
Деструктор базового класса чисто виртуальный, благодаря чему исправлена ошибка согласно правилу 50 и при этом класс PhoneInfo 
остается абстрактным. Виртуальная функция LogInfo больше не чисто виртуальная. Вызывается через добавленную публичную функцию 
Log_Info(). После конструирования, при вызове Log_Info() через указатель на базовый класс сработает полиморфизм и будет выполнен 
вызов Log_Info() из производного класса. 

//PhoneInfo.h
class PhoneInfo
{
public:
	PhoneInfo(const std::string& number, const std::string& countryCode, const std::string& model)
		:m_model(model)  
		,m_fullNumber(countryCode + number)
		,m_number(number)
		,m_countryCode(countryCode)
	{
		Log_Info();
	}

	virtual ~PhoneInfo() = 0
	{
		Log_Info();
	}

	void Log_Info()
	{
		LogInfo();
	}

private:
	virtual void LogInfo()
	{
		/*Log info*/
		std::cout << "Logged in base!\n";
	}

private:
	std::string m_model;
	std::string m_fullNumber;
	std::string m_number;
	std::string m_countryCode;
};

class IPhone : public PhoneInfo
{
public:
	IPhone(const std::string& number, const std::string& countryCode, const std::string& model)
		: PhoneInfo(number, countryCode, model)
	{}

private:
	void LogInfo()
	{
		std::cout << "Logged in Derived!\n";
	}
};


2. Дана структура Test

struct Test
{
    std::string data;
};
Напишите класс, содержащий в членах указатель на структуру Test. Этот класс должен быть копируемым, определите все необходимые
методы для того, чтобы копирование стало возможным. Обеспечьте строгую гарантию безопасности исключений при копировании.

//Header.h
struct Test
{
	std::string data;
};

class SomeClass
{
public:
	explicit SomeClass(Test *ptr = nullptr) : pTest(ptr) {}
	SomeClass(const SomeClass& rObj);
	SomeClass(SomeClass&& rObj);
	SomeClass& operator=(const SomeClass& rObj);
	SomeClass& operator=(SomeClass&& rObj);
	~SomeClass();
private:
	void AllocNew();
	void Dealloc();

	Test *pTest;
};

//Header.cpp
SomeClass::SomeClass(const SomeClass &rObj) : pTest(nullptr)
{
	*this = rObj; //используется оператор присваивания
}

//Move copy constructor
SomeClass::SomeClass(SomeClass&& rObj): pTest(nullptr)
{
	*this = std::move(rObj);
}

SomeClass& SomeClass::operator=(const SomeClass& rObj)
{
	if (this != &rObj && rObj.pTest)
	{
		Test* old = this->pTest; //save old pointer
		this->AllocNew(); //allocate memory for new pointer (possible exception)
		
		try
		{
			this->pTest->data = rObj.pTest->data;
			delete old; //if Alloc was okay
		}
		catch (const std::bad_alloc& ba)
		{
			delete this->pTest;
			this->pTest = old; //if Alloc wasn't okay
		}
	}

	return *this;
}

//Move assignment operator
SomeClass& SomeClass::operator=(SomeClass && rObj)
{
	if (this != &rObj)
	{
		this->pTest = rObj.pTest;
		rObj.pTest = nullptr;
	}

	return *this;
}

SomeClass::~SomeClass()
{
	this->Dealloc();
}

//Allocate memory
void SomeClass::AllocNew()
{
	try
	{
		this->pTest = new Test;
	}
	catch (const std::bad_alloc& ba)
	{
		throw;
	}
}

//Free memory
void SomeClass::Dealloc()
{
	if (pTest)
		delete pTest;
}

####доработка####
Конструктор копирования SomeClass(const SomeClass &rObj) переиспользует код оператора присваивания operator=(const SomeClass& rObj).
Строгая гарантия безопасности исключений (в случае возникновения исключений, изменение произошедшее в состоянии обьекта обратимо)
обеспечивается в оператором присваивания. Переиспользование кода оператора присваивания в конструкторе нарушает строгую гарантию
безопасности исключения при копировании, т.к. согласно строгой гарантии, в результате возникновения ошибки в некой процедуре состояние
программы должно быть таким, каким оно было до выполнения процедуры. То есть, при возникновении ошибки при вызове конструктора копирования
обьект не должен быть сконструирован, или должен быть сконструирован как копия объекта справа, если ошибок не было. В данном же случае, при
переиспользовании кода оператора присваивания, после ошибки объект все равно сконструируется, но со значение nullptr у pTest
(принцип все или ничего нарушен).

Безопасный в отношении ошибок код возможен если каждая функция обспечивает как можно более строгую гарантию безсбойности.
Мнимальная гарантия безопасности исключений (базовая) гарантирует не только то, что будут отсутствовать утечки ресурса памяти,
но и то, что состояние программы останется согласованным. Если принять тот факт, что при возникновении оишбки при копировании объект
типа SomeClass будет иметь pTest со значением nullptr за согласованное состояние, то мы обеспечиваем хотя бы базовую гарантию (у нас
нет утечек и pTest имеет значение предусмотренное в случае возникновения ошибки при копировании).

При возникновении исключения при попытке выделения памяти в строке 129 с точки зрения базовой гарантии не нужен перехват, т.к. не будет
утечек и состояние обьекта не изменится (поэтому вызов AllocNew() вынесен за пределы блока try). Но для обспечения хотя бы минимальной
базовой гарантии безопасности исключений перехват исключения все же необходим, но в строке 133, т.к. если в 
AllocNew() не возникнет std::bad_alloc, но оно возникнет в строке this->pTest->data = rObj.pTest->data (оператор присваивания std::string
может генерировать исключение), то будет утечка памяти (память выделенная в строке 129 не будет освобождена), поэтому мы перехватываем  
std::bad_alloc (строка 136).

##################

3. Чем чревата срезка объектов и как её избежать?

Когда в функцию передается обьект производного класса с целью использования полиморфного поведения (вызова методов производного класса
через ссылку или указатель на базовый) и, при этом, формальный параметр функции указан как тип базового класа по значению происходит 
срезка типа до типа базового класса, т.к. при передаче по значению вызывается конструктор копирования базового класса и конструируется 
копия базовой части обьекта. На этом полиморфизм заканчивается и для всех методов, которые будут вызваны, будут вызваны их базовые 
версии. Во избежания, если требуется сохранить полиформное поведение, нужно указывать в сигнатуре функции передачу по ссылке или 
указателю на базовый класс. Так же, поместить копирующий конструктор базового класса в защищенную секцию, что не даст выполнять срезку,
а для копирования предусмотреть виртуальную функцию копирования и переопределять ее в производных классах.

####доработка####
Вариант с конструктором копирования в защищенной секции оказывается возможным если деструктор базового класса не чисто невиртуальный. 
Если деструктор базового класса чисто виртуальный, и мы укажем в некой свободной функции входной параметр базового типа по значению, 
то мы увидим ошибку компиляции еще на этапе определения функции, т.к. нельзя конструировать объекты абстрактных классов. 
В предположении, что деструктор обычный виртуальный, мы можем по ошибке определить функцию, получающую параметр базового типа по значению,
и, если при этом, конструктор копирования базового класса будет в защищенной секции срезка будет предотвращена при попытке вызова такой
функции (будет ошибка компиляции, сигнализирующая о том, что конструктор копирования базового класса недоступен). 
При этом мы сможем по прежнему копировать обьекты производного класса, т.к. в конструктор копирования производного класса имеет доступ
к конструктору копирования базового (т.к. секция защищенная, а не приватная). Туда же можно поместить и оператор присваивания.

Свободная функция
void Func(const SomeBase obj) //Забыл указать & или * по ошибке
{
	/*Some interactions with obj*/
}

Иерархия
class SomeBase
{
public:
	SomeBase()
	{
		std::cout << "Default!\n";
	}
	virtual ~SomeBase() {}
protected:
	SomeBase(const SomeBase& sbObj)
	{
		std::cout << "Base!\n";
	}
};

class SomeDerived : public SomeBase
{
public:
	SomeDerived() {}
	SomeDerived(const SomeDerived& sdObj): SomeBase(sdObj)
	{
		std::cout << "Derived!\n";
	}
};

//Обьекты производного класса. Их копирования работает. Производный лкасс вызывает конструктор копирования базового
SomeDerived sd;
SomeDerived sd1(sd);

Func(sd); //ошибка компиляции. Конструктор копирования базового класса недоступен

Но мы не сможем копировать объекты базового класса напрямую.

SomeBase sb;
SomeBase sb1(sb); //ошибка компиляции. Конструктор копирования базового класса недоступен. 

В таком случае, придется определить функцию клонирования обьектов базового класса, но я все равно не смогу передать их в функцию
по значению. То есть, подход с конструктором копирования базового класса в защищенной секции подойдет когда нам не потребуется 
создавать эти обьекты напрямую в принципе (чего можно достичь, если сделать базовый класс абстрактным), и когда нам не требуется
их передавать их по значению в функции.

Более простой вариант предотвратить срезку - сделать конструктор копирования базового класса explicit. Тогда при попытке вызова
Func получим ошибку компиляции, которая сообщает, что невозможно подобрать подходящее преобразование. Все остальное (передача по ссылке
или по указателю на базовый класс, создание обьектов производного и базового классов из копий) будет работать.

explicit SomeBase(const SomeBase& sbObj)
{
	std::cout << "Base!\n";
}

SomeDerived sd; 
SomeDerived sd1(sd); //ok
SomeBase sb;
SomeBase sb1(sd); //ok
SomeBase sb2(sb1); //ok
Func(sb); //Ошибка компиляции

##################
